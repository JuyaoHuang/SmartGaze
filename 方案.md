## 人脸数据输入

人脸识别需要经过两个模型的处理，它们都有严格的数据输入格式要求。

人脸识别的数据流为：

```
原始图片 -> opencv缩放处理 -> RetinaFace处理得到五个特征点 -> opencv进行仿射变换进行人脸对齐 
-> 对齐后的图片传入mobileface进行向量化 -> 得到向量
```

**RetinaFace** 模型输入的固定尺寸是 **320x320**。**mobileface** 的尺寸是 **112x112**。

在第一步 RetinaFace 处理前，对输入图片进行以下处理：

```
OV5640 (输出 640x480, BGR) -> cv.resize (缩放到 320x320, BGR) 
-> CvtColor (转为 320x320, RGB)
-> rknn_inputs_set (填入 NPU 的输入内存)
-> rknn_run (NPU 推理)
```

1. 使用 `cv::resize` 将输入的 640x480 图片直接缩放为 320x320

   示例：

   ```c++
   cv::Mat frame; 
   camera >> frame; // 假设 frame 是 640x480
   
   cv::Mat img_320;
   // 直接缩放到 320x320
   cv::resize(frame, img_320, cv::Size(320, 320));
   ```

2. CvtColor 将图片的格式从 BGR 转为 RGB

   示例：

   ```c++
   cv::Mat img_rgb;
   cv::cvtColor(img_320, img_rgb, cv::COLOR_BGR2RGB);
   ```

## 人脸识别部分

一个人脸识别门禁的流水线通常包含三个环节：

1. **人脸检测**：找出图中有没有人脸，在哪里（坐标），关键点（眼睛鼻子嘴巴）   => 使用 RetinaFace
2. **人脸对齐**：根据关键点把人脸“摆正”并裁剪出来，通常是 112x112 像素  => 使用 OpenCV
3. **人脸特征提取**：把对齐后的人脸变成一串数字（特征向量）  => 使用 Mobilefacenet

### 1. 模型与数据集获取

- RetinaFace  使用 rknn_model_zoo 获取
- Mobilefacenet  获取训练好的 onnx 模型：https://huggingface.co/garavv/arcface-onnx/blob/main/

### 2. 模型训练

RetinaFace 模型训练效果已经很好，直接使用[RetinaFace_mobile320.onnx](https://ftrg.zbox.filez.com/v2/delivery/data/95f00b0fc900458ba134f8b180b3f7a1/examples/RetinaFace/RetinaFace_mobile320.onnx)即可。

关于 Mobilefacenet ，由于网上没有现成的 .onnx 模型，需要自己从头训练和转换。

数据集选择：CASIA-WebFace，来源：从 kaggle 平台下载：https://www.kaggle.com/datasets/ntl0601/casia-webface?select=casia-webface

```python
import kagglehub

# Download latest version
path = kagglehub.dataset_download("ntl0601/casia-webface")

print("Path to dataset files:", path)
```

使用 Mobileface 的父项目：https://github.com/TreB1eN/InsightFace_Pytorch?tab=readme-ov-file 提供的代码进行训练。

由于该项目版本过旧（九年前），训练脚本基本不能用（依赖地狱），因此我根据 Mobileface 的模型结构重新编写一个训练脚本（train_modern.py），代码会上传到 GitHub 上，后续给出仓库链接。

| 问题                                                         | 解决方案                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 训练Mobileface 模型时路径依赖问题：from PIL import Image 路径依赖报错 | 重构训练脚本，使用 cv2 进行图片读取，避免使用 PIL 读取文件   |
| 调用 tensorboard 时原项目 charset_normalizer 包损坏          | 重新安装包：`  pip uninstall charset_normalizer -y pip install charset_normalizer` |

**训练结果**：

**1.训练损失**：

![loss](./2.jpg)

**2.准确率**：

![a](1.jpg)

### 3. 模型转换

该部分包含两个步骤：1. 将 pytorch 模型转化为 .onnx 模型；2. 将 .onnx 模型转换为 .rknn 模型，实现在开发板上的人脸检测推理。

**1. ONNX 模型转换脚本**

在根目录新建脚本：convert_to_onnx.py 完成转换

```python
def convert_to_onnx(checkpoint_path, output_path, input_shape=(1, 3, 112, 112)):
    """
    将PyTorch模型转换为ONNX格式

    Args:
        checkpoint_path: PyTorch模型权重路径 (.pth)
        output_path: 输出ONNX模型路径 (.onnx)
        input_shape: 输入张量形状 (batch, channels, height, width)
    """
```

**2. ONNX 转换为 RKNN 的脚本（量化优化）**

在根目录新建脚本：convert_onnx_to_rknn.py 实现 onnx 转换到 rknn。将数据量化为 INT8，优化推理速度。

```python
def load_calibration_data(dataset_path, label_file, max_images=50):
    """
    加载量化校准数据集，并保存为txt格式供RKNN使用

    Args:
        dataset_path: 数据集根目录 (datasets/int_data)
        label_file: 标签文件 (int_data_labels.txt)
        max_images: 最多使用多少张图片进行校准（默认50张）

    Returns:
        dataset_txt_path: 校准数据集路径列表文件（.txt）
    """
def convert_onnx_to_rknn(onnx_path, rknn_path, dataset_path, label_file,
                         do_quantization=True, max_calib_images=50):
    """
    将ONNX模型转换为RKNN模型

    Args:
        onnx_path: 输入ONNX模型路径
        rknn_path: 输出RKNN模型路径
        dataset_path: 校准数据集路径
        label_file: 校准数据集标签文件
        do_quantization: 是否进行INT8量化
        max_calib_images: 最多使用多少张图片进行校准
    """
```

**量化结果**：

![4](3.jpg)

### 4. 连扳推理



## 人脸识别系统接口设计

由于python性能在处理数据下表现比C++差，人脸识别系统使用 C++ 编写所有的数据处理操作和胶水件。

该部分接口应为：

1. 接收图片的二进制数据、RetinaFace 和 Mobileface 模型的路径，以及空的内存块
2. 返回图片向量化后的向量数据

该部分分为两个内容：

1. **数据预处理**：后端将图片、两个模型路径，内存块发送给模型接口
2. **胶水件编写**：由于 RetinaFace 只是检测有无人脸，且其输出的数据尺寸为 320x320，不满足 Mobileface 输入尺寸 112x112 的要求。因此需要制作一个胶水脚本，将经过 RetinaFace 的图片旋转对齐（不歪），并调整图片大小。



